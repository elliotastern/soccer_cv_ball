<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVAT Annotations Editor - Bounding Boxes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 0;
            overflow-x: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .header {
            background: #2a2a2a;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4CAF50;
            flex-shrink: 0;
        }
        .header h1 {
            color: #4CAF50;
            font-size: 20px;
            margin: 0;
        }
        .status-bar {
            display: flex;
            gap: 20px;
            font-size: 12px;
            color: #aaa;
        }
        .status-item {
            display: flex;
            gap: 5px;
        }
        .status-value {
            color: #4CAF50;
            font-weight: bold;
        }
        .header-actions {
            display: flex;
            gap: 10px;
        }
        .icon-button {
            background: #333;
            border: none;
            color: #4CAF50;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-button:hover {
            background: #3a3a3a;
        }
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .video-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .video-wrapper {
            position: relative;
            background: #000;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #videoCanvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: block;
            cursor: crosshair;
            object-fit: contain;
            transform-origin: center;
            transition: transform 0.1s;
        }
        .canvas-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        .canvas-controls button {
            background: rgba(42, 42, 42, 0.9);
            border: 1px solid #4CAF50;
            color: #4CAF50;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        .canvas-controls button:hover {
            background: rgba(76, 175, 80, 0.2);
        }
        video {
            display: none;
        }
        .timeline-container {
            background: #2a2a2a;
            padding: 15px;
            border-top: 2px solid #333;
            flex-shrink: 0;
        }
        .timeline-wrapper {
            position: relative;
            margin-bottom: 10px;
        }
        #frameSlider {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            outline: none;
            position: relative;
        }
        .timeline-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            pointer-events: none;
        }
        .timeline-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: #4CAF50;
            opacity: 0.6;
        }
        .timeline-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .frame-display {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
            min-width: 150px;
            text-align: center;
        }
        .playback-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .playback-speed {
            background: #333;
            border: 1px solid #4CAF50;
            color: #4CAF50;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .playback-speed:hover {
            background: #3a3a3a;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #45a049;
        }
        button.delete {
            background: #f44336;
        }
        button.delete:hover {
            background: #da190b;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }
        .object-sidebar {
            width: 250px;
            background: #2a2a2a;
            border-left: 2px solid #333;
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }
        .object-sidebar h3 {
            color: #4CAF50;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
        }
        .object-track-item {
            background: #333;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: pointer;
            border-left: 4px solid #4CAF50;
        }
        .object-track-item:hover {
            background: #3a3a3a;
        }
        .object-track-item.selected {
            border-left-color: #FF9800;
            background: #3a3a3a;
        }
        .object-track-item.player {
            border-left-color: #2196F3;
        }
        .object-track-item.ball {
            border-left-color: #FFC107;
        }
        .track-label {
            font-weight: bold;
            color: #4CAF50;
        }
        .track-info {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }
        .box-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .box-item {
            background: #333;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            border-left: 3px solid #4CAF50;
            font-size: 12px;
        }
        .box-item:hover {
            background: #3a3a3a;
        }
        .box-item.selected {
            border-left-color: #FF9800;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #4CAF50;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .modal-header h2 {
            color: #4CAF50;
        }
        .close-modal {
            background: #f44336;
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
        }
        .shortcuts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 13px;
        }
        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: #333;
            border-radius: 4px;
        }
        .shortcut-key {
            background: #1a1a1a;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            color: #FF9800;
            font-weight: bold;
        }
        .debug-panel {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
            z-index: 9999;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #0f0;
        }
        .debug-panel.collapsed {
            max-height: 30px;
            overflow: hidden;
        }
        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            cursor: pointer;
        }
        .debug-toggle {
            color: #0f0;
            font-size: 12px;
        }
        .debug-content {
            max-height: 150px;
            overflow-y: auto;
        }
        .debug-panel.collapsed .debug-content {
            display: none;
        }
        #playOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            z-index: 50;
        }
        #playOverlay div {
            color: #4CAF50;
            font-size: 24px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚öΩ CVAT Annotations Editor</h1>
            <div class="status-bar" id="statusBar">
                <div class="status-item">Frames: <span class="status-value" id="statFrames">0</span></div>
                <div class="status-item">Tracks: <span class="status-value" id="statTracks">0</span></div>
                <div class="status-item">Boxes: <span class="status-value" id="statBoxes">0</span></div>
                <div class="status-item">Events: <span class="status-value" id="statEvents">0</span></div>
            </div>
            <div class="header-actions">
                <button class="icon-button" onclick="toggleHelp()" title="Help">?</button>
                <button class="icon-button" onclick="toggleShortcuts()" title="Keyboard Shortcuts">‚å®</button>
            </div>
        </div>

        <div class="main-content">
            <div class="video-container">
                <div class="video-wrapper" id="videoWrapper">
                    <div class="canvas-controls">
                        <button onclick="zoomIn()" title="Zoom In">+</button>
                        <button onclick="zoomOut()" title="Zoom Out">-</button>
                        <button onclick="resetZoom()" title="Reset Zoom">‚åÇ</button>
                    </div>
                    <canvas id="videoCanvas"></canvas>
                    <video id="video" crossorigin="anonymous" preload="metadata">
                        <source src="data/raw/real_data/37CAE053-841F-4851-956E-CBF17A51C506.mp4" type="video/mp4">
                    </video>
                    <div id="playOverlay">
                        <div>‚ñ∂ Click to Play Video</div>
                    </div>
                </div>

                <div class="timeline-container">
                    <div class="timeline-wrapper">
                        <div class="timeline-markers" id="timelineMarkers"></div>
                        <input type="range" id="frameSlider" min="0" max="1452" value="0" oninput="seekToFrame(this.value)">
                    </div>
                    <div class="timeline-controls">
                        <button onclick="seekToFrame(0)">‚èÆ First</button>
                        <button onclick="prevFrame()">‚è™ Prev</button>
                        <div class="frame-display">Frame: <span id="currentFrame">0</span> / 1452</div>
                        <button onclick="nextFrame()">‚è© Next</button>
                        <button onclick="seekToFrame(1452)">‚è≠ Last</button>
                        <div class="playback-controls">
                            <label style="color: #888; font-size: 12px;">Speed:</label>
                            <select class="playback-speed" id="playbackSpeed" onchange="setPlaybackSpeed(this.value)">
                                <option value="0.25">0.25x</option>
                                <option value="0.5">0.5x</option>
                                <option value="0.75">0.75x</option>
                                <option value="1" selected>1x</option>
                                <option value="1.25">1.25x</option>
                                <option value="1.5">1.5x</option>
                                <option value="2">2x</option>
                            </select>
                        </div>
                        <div class="action-buttons">
                            <button onclick="undoAction()" id="undoBtn" title="Undo (‚åò+Z / Ctrl+Z)">‚Ü∂ Undo</button>
                            <button onclick="redoAction()" id="redoBtn" title="Redo (‚åò+Y / Ctrl+Y)">‚Ü∑ Redo</button>
                            <button onclick="deleteSelectedBox()" class="delete">üóëÔ∏è Delete</button>
                            <button onclick="saveAnnotations()">üíæ Save</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="object-sidebar">
                <h3>Object Tracks</h3>
                <div id="objectTracksList"></div>
                <h3 style="margin-top: 20px;">Boxes in Frame</h3>
                <div class="box-list" id="boxesList"></div>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìù How to Edit</h2>
                <button class="close-modal" onclick="toggleHelp()">√ó</button>
            </div>
            <ul style="list-style: none; padding: 0;">
                <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #2196F3;">‚Ä¢</span>
                    <strong>Click & Drag</strong> on canvas to create new bounding box
                </li>
                <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #2196F3;">‚Ä¢</span>
                    <strong>Click</strong> existing box to select it
                </li>
                <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #2196F3;">‚Ä¢</span>
                    <strong>Drag</strong> selected box corners to resize
                </li>
                <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #2196F3;">‚Ä¢</span>
                    <strong>Delete</strong> button removes selected box
                </li>
                <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #2196F3;">‚Ä¢</span>
                    <strong>Navigate frames</strong> with slider or buttons
                </li>
                <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #2196F3;">‚Ä¢</span>
                    <strong>Zoom</strong> with +/- buttons or mouse wheel
                </li>
                <li style="margin-bottom: 10px; padding-left: 20px; position: relative;">
                    <span style="position: absolute; left: 0; color: #2196F3;">‚Ä¢</span>
                    <strong>Pan</strong> by dragging when zoomed in
                </li>
            </ul>
        </div>
    </div>

    <!-- Shortcuts Modal -->
    <div class="modal" id="shortcutsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
                <button class="close-modal" onclick="toggleShortcuts()">√ó</button>
            </div>
            <div class="shortcuts-grid">
                <div class="shortcut-item">
                    <span>Play/Pause</span>
                    <span class="shortcut-key">Space</span>
                </div>
                <div class="shortcut-item">
                    <span>New Box</span>
                    <span class="shortcut-key">N</span>
                </div>
                <div class="shortcut-item">
                    <span>Delete Box</span>
                    <span class="shortcut-key">Delete</span>
                </div>
                <div class="shortcut-item">
                    <span>Toggle Overlay</span>
                    <span class="shortcut-key">H</span>
                </div>
                <div class="shortcut-item">
                    <span>Previous Frame</span>
                    <span class="shortcut-key">‚Üê</span>
                </div>
                <div class="shortcut-item">
                    <span>Next Frame</span>
                    <span class="shortcut-key">‚Üí</span>
                </div>
                <div class="shortcut-item">
                    <span>First Frame</span>
                    <span class="shortcut-key">Home</span>
                </div>
                <div class="shortcut-item">
                    <span>Last Frame</span>
                    <span class="shortcut-key">End</span>
                </div>
                <div class="shortcut-item">
                    <span>Deselect</span>
                    <span class="shortcut-key">Esc</span>
                </div>
                <div class="shortcut-item">
                    <span>Undo</span>
                    <span class="shortcut-key">‚åò+Z / Ctrl+Z</span>
                </div>
                <div class="shortcut-item">
                    <span>Redo</span>
                    <span class="shortcut-key">‚åò+Y / Ctrl+Y</span>
                </div>
                <div class="shortcut-item">
                    <span>Save</span>
                    <span class="shortcut-key">‚åò+S / Ctrl+S</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        let annotations = null;
        let currentFrame = 0;
        let video = null;
        let canvas = null;
        let ctx = null;
        let videoWidth = 0;
        let videoHeight = 0;
        let scaleX = 1;
        let scaleY = 1;
        let boxes = {};
        let selectedBox = null;
        let isDrawing = false;
        let drawStart = null;
        let isDragging = false;
        let dragHandle = null; // 'nw', 'ne', 'sw', 'se', or null for moving
        let isResizing = false;
        let showOverlay = true;
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStart = null;
        let trackMap = {}; // trackId -> track info
        let currentMousePos = {x: 0, y: 0}; // Store current mouse position for drawing
        let originalBoxPos = null; // Store original box position when dragging starts
        let historyStack = []; // Undo history
        let historyIndex = -1; // Current position in history
        const MAX_HISTORY = 50; // Maximum history entries

        // Debug panel (collapsed by default)
        const debugPanel = document.createElement('div');
        debugPanel.id = 'debugPanel';
        debugPanel.className = 'debug-panel collapsed';
        debugPanel.innerHTML = `
            <div class="debug-header" onclick="toggleDebugPanel()">
                <span class="debug-toggle">‚ñº Debug</span>
            </div>
            <div class="debug-content" id="debugContent"></div>
        `;
        document.body.appendChild(debugPanel);
        
        function toggleDebugPanel() {
            debugPanel.classList.toggle('collapsed');
            const toggle = debugPanel.querySelector('.debug-toggle');
            toggle.textContent = debugPanel.classList.contains('collapsed') ? '‚ñº Debug' : '‚ñ≤ Debug';
        }

        function debugLog(msg) {
            const content = document.getElementById('debugContent');
            const time = new Date().toLocaleTimeString();
            content.innerHTML += `<div>[${time}] ${msg}</div>`;
            content.scrollTop = content.scrollHeight;
            console.log('[DEBUG]', msg);
        }

        // Load video and annotations
        video = document.getElementById('video');
        canvas = document.getElementById('videoCanvas');
        ctx = canvas.getContext('2d');
        
        debugLog('Initialized video and canvas elements');

        video.addEventListener('loadedmetadata', () => {
            videoWidth = video.videoWidth;
            videoHeight = video.videoHeight;
            debugLog(`Video metadata loaded: ${videoWidth}x${videoHeight}`);
            
            if (videoWidth === 0 || videoHeight === 0) {
                debugLog('ERROR: Video dimensions are 0!');
                return;
            }
            
            canvas.width = videoWidth;
            canvas.height = videoHeight;
            
            const wrapper = canvas.parentElement;
            const containerWidth = wrapper.clientWidth || 800;
            const containerHeight = wrapper.clientHeight || 600;
            
            scaleX = containerWidth / videoWidth;
            scaleY = containerHeight / videoHeight;
            const scale = Math.min(scaleX, scaleY);
            
            canvas.style.width = (videoWidth * scale) + 'px';
            canvas.style.height = (videoHeight * scale) + 'px';
            
            // Ensure video is at frame 0
            video.currentTime = 0;
            video.pause();
            
            // Wait for video to be ready, then load annotations
            const onCanPlay = () => {
                video.removeEventListener('canplay', onCanPlay);
                loadAnnotations();
                // Seek to frame 0 and draw
                seekToFrame(0);
            };
            video.addEventListener('canplay', onCanPlay, { once: true });
            
            // Fallback: if video is already ready
            if (video.readyState >= 3) {
                video.removeEventListener('canplay', onCanPlay);
                loadAnnotations();
                seekToFrame(0);
            }
            
            requestAnimationFrame(drawLoop);
            updateTimelineMarkers();
        });

        function drawLoop() {
            if (video.readyState >= 2 && videoWidth > 0 && videoHeight > 0) {
                if (!video.paused) {
                    drawFrame();
                } else {
                    drawFrame();
                }
            }
            requestAnimationFrame(drawLoop);
        }

        function drawFrame() {
            if (!video || !ctx || !canvas) return;
            if (videoWidth === 0 || videoHeight === 0) {
                // Video not loaded yet, just clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            try {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Get canvas display dimensions
                const rect = canvas.getBoundingClientRect();
                const displayWidth = rect.width;
                const displayHeight = rect.height;
                
                // Calculate center of visible area
                const centerX = displayWidth / 2;
                const centerY = displayHeight / 2;
                
                // Apply transformations centered on the canvas
                ctx.save();
                
                // Move to center, scale, then move back with pan offset
                ctx.translate(centerX + panX, centerY + panY);
                ctx.scale(zoomLevel, zoomLevel);
                ctx.translate(-videoWidth / 2, -videoHeight / 2);
                
                // Draw video frame - ensure video is ready and seeked
                if (video.readyState >= 2) {
                    try {
                        ctx.drawImage(video, 0, 0, videoWidth, videoHeight);
                    } catch (e) {
                        debugLog('ERROR drawing video frame: ' + e.message);
                        // If drawImage fails, fill with dark gray to show something
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(0, 0, videoWidth, videoHeight);
                    }
                } else {
                    // Video not ready yet, fill with dark background
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, 0, videoWidth, videoHeight);
                }
                
                // Draw bounding boxes if overlay is enabled
                if (showOverlay) {
                    if (boxes[currentFrame]) {
                        boxes[currentFrame].forEach(box => {
                            drawBox(box, box.id === selectedBox?.id);
                        });
                    }
                    
                    if (isDrawing && drawStart) {
                        const rect = getMouseRect(drawStart, currentMousePos);
                        drawBox(rect, false, true);
                    }
                }
                
                ctx.restore();
            } catch (e) {
                debugLog('ERROR in drawFrame: ' + e.message);
            }
        }

        function drawBox(box, isSelected = false, isTemporary = false) {
            const x = box.xtl;
            const y = box.ytl;
            const w = box.xbr - box.xtl;
            const h = box.ybr - box.ytl;
            
            // Get label from box or trackMap - prioritize box.label
            const label = box.label || (box.trackId && trackMap[box.trackId] && trackMap[box.trackId].label) || 'player';
            
            let color = '#4CAF50';
            if (label === 'player') color = '#2196F3';
            if (label === 'ball') color = '#FFC107';
            
            ctx.strokeStyle = isSelected ? '#FF9800' : color;
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.setLineDash(isTemporary ? [5, 5] : []);
            
            ctx.strokeRect(x, y, w, h);
            
            // Draw label text with background for better visibility
            if (label && label !== 'undefined') {
                const labelText = `${label} (${(box.confidence * 100).toFixed(0)}%)`;
                ctx.font = 'bold 14px Arial';
                const textMetrics = ctx.measureText(labelText);
                const textWidth = textMetrics.width;
                const textHeight = 16;
                
                // Draw semi-transparent background for text
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(x - 2, y - textHeight - 2, textWidth + 6, textHeight + 4);
                
                // Draw text with white outline for better visibility
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 3;
                ctx.strokeText(labelText, x + 1, y - 4);
                
                // Draw text
                ctx.fillStyle = color;
                ctx.fillText(labelText, x + 1, y - 4);
            }
            
            if (isSelected && !isTemporary) {
                const handleSize = 8;
                const handles = [
                    {x: x, y: y, corner: 'nw'}, {x: x + w, y: y, corner: 'ne'},
                    {x: x, y: y + h, corner: 'sw'}, {x: x + w, y: y + h, corner: 'se'}
                ];
                handles.forEach(handle => {
                    ctx.fillStyle = dragHandle === handle.corner ? '#FF5722' : '#FF9800';
                    ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                });
            }
        }
        
        function getHandleAt(x, y, box) {
            const handleSize = 8;
            const handles = [
                {x: box.xtl, y: box.ytl, corner: 'nw'},
                {x: box.xbr, y: box.ytl, corner: 'ne'},
                {x: box.xtl, y: box.ybr, corner: 'sw'},
                {x: box.xbr, y: box.ybr, corner: 'se'}
            ];
            
            for (let handle of handles) {
                const dx = x - handle.x;
                const dy = y - handle.y;
                if (Math.abs(dx) <= handleSize/2 && Math.abs(dy) <= handleSize/2) {
                    return handle.corner;
                }
            }
            return null;
        }

        function screenToCanvas(x, y) {
            if (!canvas || videoWidth === 0 || videoHeight === 0) {
                return { x: 0, y: 0 };
            }
            
            const rect = canvas.getBoundingClientRect();
            const displayWidth = rect.width;
            const displayHeight = rect.height;
            const centerX = displayWidth / 2;
            const centerY = displayHeight / 2;
            
            // Convert screen coordinates to canvas coordinates accounting for zoom/pan
            const canvasX = (x - rect.left - centerX - panX) / zoomLevel + videoWidth / 2;
            const canvasY = (y - rect.top - centerY - panY) / zoomLevel + videoHeight / 2;
            
            return { x: canvasX, y: canvasY };
        }

        function getMouseRect(start, end) {
            const startPos = screenToCanvas(start.x, start.y);
            const endPos = screenToCanvas(end.x, end.y);
            
            return {
                xtl: Math.min(startPos.x, endPos.x),
                ytl: Math.min(startPos.y, endPos.y),
                xbr: Math.max(startPos.x, endPos.x),
                ybr: Math.max(startPos.y, endPos.y),
                label: 'player',
                confidence: 0.8
            };
        }

        // Canvas interaction
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1 || (e.button === 0 && e.ctrlKey) || (e.button === 0 && e.shiftKey)) {
                isPanning = true;
                panStart = {x: e.clientX, y: e.clientY};
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            const pos = screenToCanvas(e.clientX, e.clientY);
            
            if (boxes[currentFrame]) {
                for (let box of boxes[currentFrame]) {
                    // Check if clicking on a corner handle first
                    const handle = getHandleAt(pos.x, pos.y, box);
                    if (handle) {
                        selectedBox = box;
                        isResizing = true;
                        dragHandle = handle;
                        drawStart = {x: e.clientX, y: e.clientY};
                        originalBoxPos = {
                            xtl: box.xtl,
                            ytl: box.ytl,
                            xbr: box.xbr,
                            ybr: box.ybr
                        };
                        updateBoxesList();
                        drawFrame();
                        return;
                    }
                    
                    // Check if clicking inside the box
                    if (pos.x >= box.xtl && pos.x <= box.xbr && pos.y >= box.ytl && pos.y <= box.ybr) {
                        selectedBox = box;
                        isDragging = true;
                        isResizing = false;
                        dragHandle = null;
                        drawStart = {x: e.clientX, y: e.clientY};
                        // Store original box position to prevent coordinate drift
                        originalBoxPos = {
                            xtl: box.xtl,
                            ytl: box.ytl,
                            xbr: box.xbr,
                            ybr: box.ybr
                        };
                        updateBoxesList();
                        drawFrame();
                        return;
                    }
                }
            }
            
            isDrawing = true;
            drawStart = {x: e.clientX, y: e.clientY};
            selectedBox = null;
            updateBoxesList();
        });

        canvas.addEventListener('mousemove', (e) => {
            // Store current mouse position for drawing temporary boxes
            currentMousePos = {x: e.clientX, y: e.clientY};
            
            if (isPanning && panStart) {
                panX += e.clientX - panStart.x;
                panY += e.clientY - panStart.y;
                panStart = {x: e.clientX, y: e.clientY};
                drawFrame();
                return;
            }
            
            if (isDrawing && drawStart) {
                drawFrame();
            } else if (isResizing && selectedBox && originalBoxPos && dragHandle) {
                // Resize box by dragging corner handle
                const currentPos = screenToCanvas(e.clientX, e.clientY);
                
                switch(dragHandle) {
                    case 'nw': // Top-left
                        selectedBox.xtl = currentPos.x;
                        selectedBox.ytl = currentPos.y;
                        break;
                    case 'ne': // Top-right
                        selectedBox.xbr = currentPos.x;
                        selectedBox.ytl = currentPos.y;
                        break;
                    case 'sw': // Bottom-left
                        selectedBox.xtl = currentPos.x;
                        selectedBox.ybr = currentPos.y;
                        break;
                    case 'se': // Bottom-right
                        selectedBox.xbr = currentPos.x;
                        selectedBox.ybr = currentPos.y;
                        break;
                }
                
                // Ensure box doesn't flip (min width/height)
                if (selectedBox.xbr < selectedBox.xtl) {
                    const temp = selectedBox.xtl;
                    selectedBox.xtl = selectedBox.xbr;
                    selectedBox.xbr = temp;
                }
                if (selectedBox.ybr < selectedBox.ytl) {
                    const temp = selectedBox.ytl;
                    selectedBox.ytl = selectedBox.ybr;
                    selectedBox.ybr = temp;
                }
                
                drawFrame();
                updateBoxesList();
            } else if (isDragging && selectedBox && originalBoxPos) {
                // Calculate delta from original position to current mouse position
                const originalPos = screenToCanvas(drawStart.x, drawStart.y);
                const currentPos = screenToCanvas(e.clientX, e.clientY);
                
                const dx = currentPos.x - originalPos.x;
                const dy = currentPos.y - originalPos.y;
                
                // Apply delta to original position (prevents accumulation errors)
                selectedBox.xtl = originalBoxPos.xtl + dx;
                selectedBox.ytl = originalBoxPos.ytl + dy;
                selectedBox.xbr = originalBoxPos.xbr + dx;
                selectedBox.ybr = originalBoxPos.ybr + dy;
                
                drawFrame();
                updateBoxesList();
            } else if (selectedBox && boxes[currentFrame]) {
                // Update cursor when hovering over handles
                const pos = screenToCanvas(e.clientX, e.clientY);
                const handle = getHandleAt(pos.x, pos.y, selectedBox);
                if (handle) {
                    const cursors = {
                        'nw': 'nw-resize',
                        'ne': 'ne-resize',
                        'sw': 'sw-resize',
                        'se': 'se-resize'
                    };
                    canvas.style.cursor = cursors[handle] || 'default';
                } else if (pos.x >= selectedBox.xtl && pos.x <= selectedBox.xbr && 
                          pos.y >= selectedBox.ytl && pos.y <= selectedBox.ybr) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                panStart = null;
                canvas.style.cursor = 'crosshair';
                return;
            }
            
            if (isDrawing && drawStart) {
                const rect = getMouseRect(drawStart, {x: e.clientX, y: e.clientY});
                if (!boxes[currentFrame]) boxes[currentFrame] = [];
                rect.id = `new-${Date.now()}`;
                rect.trackId = `track-${Date.now()}`;
                
                // Save state before adding box
                saveState();
                
                boxes[currentFrame].push(rect);
                selectedBox = rect;
                isDrawing = false;
                drawStart = null;
                updateBoxesList();
                updateObjectTracks();
                updateTimelineMarkers();
                drawFrame();
            }
            
            // Save state after dragging or resizing ends
            if ((isDragging || isResizing) && originalBoxPos) {
                saveState();
            }
            
            // Reset dragging/resizing state and clear original position
            isDragging = false;
            isResizing = false;
            dragHandle = null;
            originalBoxPos = null;
            drawStart = null;
            canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Get mouse position in canvas coordinates before zoom
            const beforeZoom = screenToCanvas(e.clientX, e.clientY);
            
            // Apply zoom
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const oldZoom = zoomLevel;
            zoomLevel = Math.max(0.5, Math.min(5, zoomLevel * delta));
            
            // Get mouse position in canvas coordinates after zoom
            const afterZoom = screenToCanvas(e.clientX, e.clientY);
            
            // Adjust pan to keep the point under the mouse in the same place
            const dx = (beforeZoom.x - afterZoom.x) * zoomLevel;
            const dy = (beforeZoom.y - afterZoom.y) * zoomLevel;
            panX -= dx;
            panY -= dy;
            
            drawFrame();
        });

        function zoomIn() {
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const beforeZoom = screenToCanvas(rect.left + centerX, rect.top + centerY);
            zoomLevel = Math.min(5, zoomLevel * 1.2);
            const afterZoom = screenToCanvas(rect.left + centerX, rect.top + centerY);
            
            const dx = (beforeZoom.x - afterZoom.x) * zoomLevel;
            const dy = (beforeZoom.y - afterZoom.y) * zoomLevel;
            panX -= dx;
            panY -= dy;
            
            drawFrame();
        }

        function zoomOut() {
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const beforeZoom = screenToCanvas(rect.left + centerX, rect.top + centerY);
            zoomLevel = Math.max(0.5, zoomLevel / 1.2);
            const afterZoom = screenToCanvas(rect.left + centerX, rect.top + centerY);
            
            const dx = (beforeZoom.x - afterZoom.x) * zoomLevel;
            const dy = (beforeZoom.y - afterZoom.y) * zoomLevel;
            panX -= dx;
            panY -= dy;
            
            drawFrame();
        }

        function resetZoom() {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
            drawFrame();
        }

        function seekToFrame(frameNum) {
            currentFrame = Math.max(0, Math.min(parseInt(frameNum), 1452));
            document.getElementById('frameSlider').value = currentFrame;
            document.getElementById('currentFrame').textContent = currentFrame;
            if (video.readyState >= 2) {
                video.currentTime = currentFrame / 60;
                video.pause();
            }
            selectedBox = null;
            drawFrame();
            updateBoxesList();
        }

        function nextFrame() {
            if (currentFrame < 1452) seekToFrame(currentFrame + 1);
        }

        function prevFrame() {
            if (currentFrame > 0) seekToFrame(currentFrame - 1);
        }

        function deleteSelectedBox() {
            if (selectedBox && boxes[currentFrame]) {
                // Save state before deleting
                saveState();
                
                boxes[currentFrame] = boxes[currentFrame].filter(b => b.id !== selectedBox.id);
                selectedBox = null;
                drawFrame();
                updateBoxesList();
                updateObjectTracks();
                updateTimelineMarkers();
            }
        }

        function setPlaybackSpeed(speed) {
            video.playbackRate = parseFloat(speed);
        }

        function updateBoxesList() {
            const list = document.getElementById('boxesList');
            list.innerHTML = '';
            
            if (boxes[currentFrame] && boxes[currentFrame].length > 0) {
                boxes[currentFrame].forEach(box => {
                    const item = document.createElement('div');
                    item.className = `box-item ${box.id === selectedBox?.id ? 'selected' : ''}`;
                    item.innerHTML = `${box.label} (Track ${box.trackId})`;
                    item.onclick = () => {
                        selectedBox = box;
                        drawFrame();
                        updateBoxesList();
                    };
                    list.appendChild(item);
                });
            } else {
                list.innerHTML = '<div style="color: #888; padding: 10px; text-align: center; font-size: 11px;">No boxes</div>';
            }
        }

        function updateObjectTracks() {
            const list = document.getElementById('objectTracksList');
            list.innerHTML = '';
            
            Object.keys(trackMap).forEach(trackId => {
                const track = trackMap[trackId];
                const item = document.createElement('div');
                item.className = `object-track-item ${track.label}`;
                item.innerHTML = `
                    <div class="track-label">${track.label} (ID: ${trackId})</div>
                    <div class="track-info">Frames: ${track.frameCount}</div>
                `;
                item.onclick = () => {
                    // Highlight boxes from this track
                    selectedBox = null;
                    drawFrame();
                    updateBoxesList();
                };
                list.appendChild(item);
            });
        }

        function updateTimelineMarkers() {
            const markers = document.getElementById('timelineMarkers');
            markers.innerHTML = '';
            const slider = document.getElementById('frameSlider');
            const sliderWidth = slider.offsetWidth;
            const maxFrame = parseInt(slider.max);
            
            Object.keys(boxes).forEach(frame => {
                if (boxes[frame] && boxes[frame].length > 0) {
                    const position = (parseInt(frame) / maxFrame) * sliderWidth;
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.style.left = position + 'px';
                    markers.appendChild(marker);
                }
            });
        }

        function updateStats() {
            const task = annotations.querySelector('task');
            const frames = task ? task.querySelector('size').textContent : '0';
            const tracks = annotations.querySelectorAll('track');
            const events = annotations.querySelectorAll('tag');
            const totalBoxes = Object.values(boxes).reduce((sum, frameBoxes) => sum + frameBoxes.length, 0);
            
            document.getElementById('statFrames').textContent = frames;
            document.getElementById('statTracks').textContent = tracks.length;
            document.getElementById('statBoxes').textContent = totalBoxes;
            document.getElementById('statEvents').textContent = events.length;
        }

        function loadAnnotations() {
            // Add cache-busting timestamp to force fresh load
            const timestamp = new Date().getTime();
            fetch(`data/raw/real_data/37CAE053-841F-4851-956E-CBF17A51C506_annotations.xml?t=${timestamp}`, {
                cache: 'no-store',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(xmlText => {
                    const parser = new DOMParser();
                    annotations = parser.parseFromString(xmlText, 'text/xml');
                    parseAnnotations();
                    updateStats();
                    updateObjectTracks();
                    updateTimelineMarkers();
                    // Initialize history with initial state
                    saveState();
                    updateUndoRedoButtons();
                    // Force video to seek to current frame and redraw
                    if (video && video.readyState >= 2) {
                        // Seek to current frame to ensure video is at correct position
                        video.currentTime = currentFrame / 60;
                        video.pause();
                        // Wait for seek to complete, then draw
                        video.addEventListener('seeked', function onSeeked() {
                            video.removeEventListener('seeked', onSeeked);
                            drawFrame();
                        }, { once: true });
                        // Fallback: draw immediately if seek is instant
                        setTimeout(() => drawFrame(), 100);
                    }
                })
                .catch(error => {
                    console.error('Error loading annotations:', error);
                    alert('Error loading annotations: ' + error.message);
                });
        }

        function parseAnnotations() {
            boxes = {};
            trackMap = {};
            
            const tracks = annotations.querySelectorAll('track');
            tracks.forEach(track => {
                const trackId = track.getAttribute('id');
                const label = track.getAttribute('label') || 'player'; // Ensure label is never null/empty
                const trackBoxes = track.querySelectorAll('box');
                
                trackMap[trackId] = {
                    label: label,
                    frameCount: trackBoxes.length
                };
                
                trackBoxes.forEach(box => {
                    const frame = parseInt(box.getAttribute('frame'));
                    const xtl = parseFloat(box.getAttribute('xtl'));
                    const ytl = parseFloat(box.getAttribute('ytl'));
                    const xbr = parseFloat(box.getAttribute('xbr'));
                    const ybr = parseFloat(box.getAttribute('ybr'));
                    const conf = box.querySelector('attribute[name="confidence"]');
                    const confidence = conf ? parseFloat(conf.textContent) : 0.5;
                    
                    if (!boxes[frame]) boxes[frame] = [];
                    
                    boxes[frame].push({
                        trackId: trackId,
                        label: label || 'player', // Ensure label is always set
                        xtl: xtl,
                        ytl: ytl,
                        xbr: xbr,
                        ybr: ybr,
                        confidence: confidence,
                        id: `${trackId}-${frame}`
                    });
                });
            });
        }

        function toggleHelp() {
            document.getElementById('helpModal').classList.toggle('active');
        }

        function toggleShortcuts() {
            document.getElementById('shortcutsModal').classList.toggle('active');
        }

        function saveState() {
            // Deep clone the boxes object
            const stateCopy = JSON.parse(JSON.stringify(boxes));
            
            // Remove any states after current index (when undoing then making new changes)
            if (historyIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyIndex + 1);
            }
            
            // Add new state
            historyStack.push(stateCopy);
            
            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            } else {
                historyIndex++;
            }
            
            updateUndoRedoButtons();
        }

        function undoAction() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(historyStack[historyIndex]);
            }
        }

        function redoAction() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                restoreState(historyStack[historyIndex]);
            }
        }

        function restoreState(state) {
            boxes = JSON.parse(JSON.stringify(state));
            selectedBox = null;
            drawFrame();
            updateBoxesList();
            updateObjectTracks();
            updateTimelineMarkers();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            if (undoBtn) {
                undoBtn.disabled = historyIndex <= 0;
                undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
            }
            
            if (redoBtn) {
                redoBtn.disabled = historyIndex >= historyStack.length - 1;
                redoBtn.style.opacity = historyIndex >= historyStack.length - 1 ? '0.5' : '1';
            }
        }

        function saveAnnotations() {
            if (!annotations) {
                alert('No annotations loaded. Cannot save.');
                return;
            }
            
            try {
                // Create a copy of the original XML structure
                const serializer = new XMLSerializer();
                const xmlString = serializer.serializeToString(annotations);
                const parser = new DOMParser();
                const newDoc = parser.parseFromString(xmlString, 'text/xml');
                
                // Get the root annotations element
                const annotationsRoot = newDoc.documentElement;
                if (!annotationsRoot || annotationsRoot.nodeName !== 'annotations') {
                    throw new Error('Invalid XML structure: annotations root not found');
                }
                
                // Remove all existing track boxes (but keep tracks)
                const tracks = newDoc.querySelectorAll('track');
                tracks.forEach(track => {
                    const trackBoxes = track.querySelectorAll('box');
                    trackBoxes.forEach(box => box.remove());
                });
                
                // Rebuild boxes from current state
                Object.keys(boxes).forEach(frameNum => {
                    const frame = parseInt(frameNum);
                    if (boxes[frame] && boxes[frame].length > 0) {
                        boxes[frame].forEach(box => {
                            // Find or create the track element
                            let track = Array.from(newDoc.querySelectorAll('track')).find(t => 
                                t.getAttribute('id') === box.trackId.toString()
                            );
                            
                            if (!track) {
                                // Create new track if it doesn't exist
                                // Get label from box or trackMap
                                const label = box.label || (box.trackId && trackMap[box.trackId] && trackMap[box.trackId].label) || 'player';
                                
                                // Find where to insert (after meta, before other tracks)
                                const meta = annotationsRoot.querySelector('meta');
                                track = newDoc.createElement('track');
                                track.setAttribute('id', box.trackId.toString());
                                track.setAttribute('label', label);
                                track.setAttribute('source', 'manual');
                                
                                // Insert after meta, or append to root
                                if (meta) {
                                    // Find the next sibling after meta
                                    let insertPoint = meta.nextSibling;
                                    while (insertPoint && insertPoint.nodeType !== 1) {
                                        insertPoint = insertPoint.nextSibling;
                                    }
                                    if (insertPoint) {
                                        annotationsRoot.insertBefore(track, insertPoint);
                                    } else {
                                        annotationsRoot.appendChild(track);
                                    }
                                } else {
                                    annotationsRoot.appendChild(track);
                                }
                            } else {
                                // Update existing track label if box has a label and it's different
                                const label = box.label || (box.trackId && trackMap[box.trackId] && trackMap[box.trackId].label);
                                if (label && track.getAttribute('label') !== label) {
                                    track.setAttribute('label', label);
                                }
                            }
                            
                            // Create box element
                            const boxElem = newDoc.createElement('box');
                            boxElem.setAttribute('frame', frame.toString());
                            boxElem.setAttribute('xtl', box.xtl.toFixed(2));
                            boxElem.setAttribute('ytl', box.ytl.toFixed(2));
                            boxElem.setAttribute('xbr', box.xbr.toFixed(2));
                            boxElem.setAttribute('ybr', box.ybr.toFixed(2));
                            boxElem.setAttribute('occluded', '0');
                            boxElem.setAttribute('outside', '0');
                            boxElem.setAttribute('keyframe', '1');
                            
                            // Add confidence attribute
                            const confAttr = newDoc.createElement('attribute');
                            confAttr.setAttribute('name', 'confidence');
                            confAttr.textContent = (box.confidence || 0.8).toFixed(3);
                            boxElem.appendChild(confAttr);
                            
                            track.appendChild(boxElem);
                        });
                    }
                });
                
                // Serialize to string with proper formatting
                const finalXml = serializer.serializeToString(newDoc);
                const formattedXml = formatXML(finalXml);
                
                // Save to server
                fetch('/save_annotations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        xml: formattedXml,
                        file_path: 'data/raw/real_data/37CAE053-841F-4851-956E-CBF17A51C506_annotations.xml'
                    })
                })
                .then(response => {
                    // Check if response is actually JSON
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        return response.json();
                    } else {
                        // If not JSON, read as text to see what we got
                        return response.text().then(text => {
                            throw new Error(`Server returned non-JSON response: ${text.substring(0, 100)}`);
                        });
                    }
                })
                .then(data => {
                    if (data.success) {
                        // Reload annotations to show the saved changes immediately
                        loadAnnotations();
                        // Force video seek and redraw
                        if (video && video.readyState >= 2) {
                            video.currentTime = currentFrame / 60;
                            video.addEventListener('seeked', function onSeeked() {
                                video.removeEventListener('seeked', onSeeked);
                                drawFrame();
                            }, { once: true });
                            setTimeout(() => drawFrame(), 100);
                        }
                        alert('Annotations saved successfully! The XML file has been updated.');
                    } else {
                        alert('Error saving annotations: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('Error saving annotations:', error);
                    alert('Error saving annotations: ' + error.message);
                });
            } catch (error) {
                console.error('Error saving annotations:', error);
                alert('Error saving annotations: ' + error.message);
            }
        }
        
        function formatXML(xml) {
            // Simple XML formatting (indentation)
            let formatted = '';
            let indent = 0;
            const tab = '  ';
            
            xml.split(/>\s*</).forEach(node => {
                if (node.match(/^\/\w/)) indent--;
                formatted += tab.repeat(Math.max(0, indent)) + '<' + node + '>\r\n';
                if (node.match(/^<?\w[^>]*[^\/]$/) && !node.startsWith('xml')) indent++;
            });
            
            return formatted.substring(1, formatted.length - 2);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }

            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    if (video.readyState >= 2) {
                        if (video.paused) {
                            video.play().catch(e => console.log('Play failed:', e));
                            document.getElementById('playOverlay').style.display = 'none';
                        } else {
                            video.pause();
                            document.getElementById('playOverlay').style.display = 'block';
                        }
                    }
                    break;
                case 'h':
                case 'H':
                    e.preventDefault();
                    showOverlay = !showOverlay;
                    drawFrame();
                    break;
                case 'n':
                case 'N':
                    e.preventDefault();
                    // Enter new box mode
                    break;
                case 'Delete':
                case 'Backspace':
                    if (selectedBox) {
                        e.preventDefault();
                        deleteSelectedBox();
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevFrame();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextFrame();
                    break;
                case 'Home':
                    e.preventDefault();
                    seekToFrame(0);
                    break;
                case 'End':
                    e.preventDefault();
                    seekToFrame(1452);
                    break;
                case 'Escape':
                case 'Esc':
                    e.preventDefault();
                    selectedBox = null;
                    drawFrame();
                    updateBoxesList();
                    break;
            }

            // Ctrl+Z (Windows/Linux) or Cmd+Z (Mac) to undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoAction();
            }
            
            // Ctrl+Y or Ctrl+Shift+Z (Windows/Linux) or Cmd+Y or Cmd+Shift+Z (Mac) to redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) {
                e.preventDefault();
                redoAction();
            }
            
            // Ctrl+S (Windows/Linux) or Cmd+S (Mac) to save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveAnnotations();
            }
        });

        video.addEventListener('timeupdate', () => {
            const frame = Math.floor(video.currentTime * 60);
            if (Math.abs(frame - currentFrame) > 1) {
                currentFrame = frame;
                document.getElementById('frameSlider').value = currentFrame;
                document.getElementById('currentFrame').textContent = currentFrame;
                updateBoxesList();
            }
        });

        video.addEventListener('play', () => {
            document.getElementById('playOverlay').style.display = 'none';
        });

        video.addEventListener('pause', () => {
            if (video.readyState >= 2) {
                document.getElementById('playOverlay').style.display = 'block';
            }
        });

        canvas.setAttribute('tabindex', '0');
        canvas.addEventListener('click', () => {
            canvas.focus();
        });

        video.load();
    </script>
</body>
</html>
